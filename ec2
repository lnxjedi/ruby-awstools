#!/usr/bin/ruby

require 'pathname'
script_dir = File.dirname(Pathname.new(__FILE__).realpath)

require 'optparse'
require 'yaml'
require 'rubygems'
Dir::chdir(script_dir) do
	require 'bundler/setup'
	require 'aws-sdk'
	require_relative 'lib/cloud'
end

cfgfile = ENV["RAWS_CLOUDCFG"]

opts = OptionParser.new

opts.banner = <<-EOF
Usage: ec2 <command> (options) (args) - manage a CloudFormation stack
 Where <command> is one of:
  create <name/dns prefix> <keyname> <template> <availability_zone> - create one or more instances from a template (name or path)
  updatedns <instancename|instanceid> - update A records for an instance
  deletekeypair <keyname>
  genkeypair <keyname> (outputdir) - generate a keypair and store it in <keyname>.pem
  start <instancename|instanceId> - start a stopped instance; i-* are assumed instance ID
 Options are:
EOF
opts.on("-c", "--configfile FILE", "Use FILE for cloud configuration instead of ./cloudconfig.yaml") do |file|
	cfgfile = file
end

class UsageException < Exception
	def initialize(msg="Invalid command / option / argument")
		super(msg)
	end
end

begin

commands = [ "create", "updatedns", "deletekeypair", "genkeypair", "start" ]
command = ARGV.shift()
raise UsageException.new("Missing <command>") unless command
raise UsageException.new("Unknown command: #{command}") unless commands.include?(command)

params = {}
tags = {}
dns = true
wait = false
datasize = nil

case command
when "create"
	opts.on("-d", "--data-vol SIZE", "Create with a new data volume of size SIZE") do |dsize|
		datasize = dsize
	end
	opts.on("-N", "--no-dns", "Don't create DNS records for <name>.${DNSDomain}") do
		dns = false
	end
	opts.on("-w", "--wait", "Wait for DNS records to sync") do
		wait = true
	end
	opts.on("-e", "--ebs-optimized", "Create ebs-optimized instances") do
		params["ebsoptimized"] = true
	end
	opts.on("-i", "--iops IOPS", "Specify provisioned iops, only used with io1 volumes") do |iops|
		params["iops"] = iops
	end
	opts.on("-m", "--monitoring", "Enable ec2 monitoring (CPU, disk/network, status checks)") do
		params["monitor"] = true
	end
	opts.on("-s", "--snapshot SNAP", "Create data volume from snapshot (id or name)") do |snap|
		params["snapname"] = snap
	end
	opts.on("-v", "--volume VOL", "Attach the given data volume (id or name)") do |vol|
		params["volname"] = vol
	end
	opts.on("-V", "--volume-type TYPE", "Create a new volume of type TYPE (gp2, io1, etc.)") do |vtype|
		params["volume_type"] = vtype
	end
	opts.on("-t", "--instance-type TYPE", "Use TYPE for instance type instead of template default") do |type|
		params["type"] = type
	end
	opts.on("-r", "--root-size SIZE", "Increase root volume size to SIZE") do |size|
		params["rootsize"] = size
	end
	opts.on("-T", "--tag KEYVAL", "Add tag where KEYVAL is of the form key=value") do |keyval|
		e = keyval.index("=")
		key = keyval[0..(e-1)]
		value = keyval[(e+1)..-1]
		tags[key] = value
	end
	opts.on("-p", "--parameter PARAMVAL", "Set an arbitrary parameter where PARAMVAL is of the form parameter=value") do |keyval|
		e = keyval.index("=")
		key = keyval[0..(e-1)]
		value = keyval[(e+1)..-1]
		params[key] = value
	end
when "updatedns"
	opts.on("-w", "--wait", "Wait for DNS records to sync") do
		wait = true
	end
end

opts.parse!

cfgfile = "cloudconfig.yaml" unless cfgfile

raise UsageException.new("Missing configuration file: #{cfgfile}") unless File::exist?(cfgfile)
raise UsageException.new("Not a regular file: #{cfgfile}") unless File::stat(cfgfile).file?

cfg = RAWSTools::CloudManager.new(cfgfile, script_dir)
cfg.setparams(params)

case command
when "create"
	name, key, template, az = ARGV.shift(4)
	raise UsageException.new("Missing required argument") unless az
	raise UsageException.new("Error: both snapshot and volume specified") if params["snapname"] and params["volname"]
	cfg.setparam("name", name)
	cfg.setparam("key", key)
	cfg.normalize_name_parameters()
	if params["volname"]
		raise UsageException.new("Error: volume \"#{params}\" not found") unless cfg.ec2.resolve_volume()
	else
		cfg.setparam("volname", cfg.getparam("name"))
		volume = cfg.ec2.resolve_volume(false)
	end
	# one-liner to validate the key
	cfg.ec2.resource.key_pair(key).key_name()
	raise "Instance #{name} already exists" if cfg.ec2.resolve_instance(false)
	cfg.setparam("az", az.upcase())
	instance = cfg.ec2.create_instance_from_template(template)
	puts "Created instance \"#{cfg.getparam("name")}\"(id: #{instance.id()})"
	if snapshot or datasize
		if volume
			raise "Error: volume \"#{cfg.getparam("volname")}\" already exists; delete or rename before creating a new volume"
		else
			volume = cfg.ec2.create_volume(datasize)
			puts "Created new data volume \"#{cfg.getparam("volname")}\"(id: #{volume.id()})"
		end
	end
	puts "Waiting for instance to enter state \"running\" ..."
	cfg.ec2.wait_running()
	puts "Running"
	if volume
		puts "Attaching data volume \"#{cfg.getparam("volname")}\"(id: #{volume.id()})"
		cfg.ec2.attach_volume()
	end
	cfg.ec2.tag_instance_resources()
	if dns
		puts "Updating DNS"
		puts "Waiting for zones to synchronize..." if wait
		cfg.ec2.update_dns(wait)
		puts "Synchronized" if wait
	end
when "updatedns"
	name = ARGV.shift()
	raise UsageException.new("Missing required argument") unless instance
	puts "Updating DNS"
	puts "Waiting for zones to synchronize..." if wait
	cfg.ec2.update_dns(wait)
	puts "Synchronized" if wait
when "start"
	instance = ARGV.shift()
	raise UsageException.new("Missing <instancename|instanceId> argument") unless instance
	puts "Starting #{ispec}, dnsname is #{dnsname}.#{cfg["PublicDNS"]}"
when "genkeypair"
	keyname = ARGV.shift()
	raise UsageException.new("Missing <keyname> argument") unless keyname
	outputdir = ARGV.shift()
	if outputdir
		raise UsageException.new("Not a directory: #{outputdir}") unless File::stat(outputdir).directory?
		outputdir += "/" unless outputdir.end_with?("/")
		keyfilename = "#{outputdir}#{keyname}.pem"
	else
		keyfilename = "#{keyname}.pem"
	end
	raise UsageException.new("File already exists: #{keyfilename}") if File::exist?(keyfilename)
	puts "Creating keypair #{keyname} and storing in #{keyfilename}"
	key = cfg.ec2.create_key_pair({key_name: keyname})
	keyfile = File.open(keyfilename, "w")
	keyfile.write(key.key_material())
	keyfile.close()
when "deletekeypair"
	keyname = ARGV.shift()
	raise UsageException.new("Missing <keyname> argument") unless keyname
	cfg.ec2.delete_key_pair({key_name: keyname})
	puts "Deleted"
end

rescue UsageException => e
	puts "\n#{e.message}\n\n"
	puts opts.help()
end
