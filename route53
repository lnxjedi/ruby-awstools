#!/usr/bin/ruby

require 'pathname'
script_dir = File.dirname(Pathname.new(__FILE__).realpath)

require 'optparse'
require 'yaml'
require 'rubygems'
Dir::chdir(script_dir) do
	require 'bundler/setup'
	require 'aws-sdk'
	require_relative 'lib/cloud'
	#require_relative 'lib/cfnlib'
end

cfgfile = ENV["RAWS_CLOUDCFG"]
wait = false

opts = OptionParser.new
ttl = nil

opts.banner = <<-EOF
Usage: route53 <command> (options) (args) - manage route53 records
 Where <command> is one of:
  arec <public|private|both> <host(.subdom)> <ipaddr> - inserts/updates A records in given domains, uses route53/arec.yaml
  cname <public|private|both> <cnamehost(.subdom)> <arechost(.subdom)> - inserts/updates CNAME records in given domains, uses route53/cname.yaml
  txt <public|private|both> <name(.subdom)> "string" - inserts/updates a TXT record, uses route53/txt.yaml
  lookup <public|private> <name> - query route53 for the value(s) corresponding to a name
 Options are:
EOF
opts.on("-t", "--ttl TTL", "Use TTY instead of configured default") do |value|
	ttl = value
end
opts.on("-w", "--wait", "Wait for records to sync before exiting") do
	wait = true
end
opts.on("-c", "--configfile FILE", "Use FILE for cloud configuration instead of ./cloudconfig.yaml") do |file|
	cfgfile = file
end

class UsageException < Exception
	def initialize(msg="Invalid command / option / argument")
		super(msg)
	end
end

begin

commands = [ "arec", "txt", "cname", "lookup" ]
command = ARGV.shift()
raise UsageException.new("Missing <command>") unless command
raise UsageException.new("Unknown command: #{command}") unless commands.include?(command)

opts.parse!

cfgfile = "cloudconfig.yaml" unless cfgfile

raise UsageException.new("Missing configuration file: #{cfgfile}") unless File::exist?(cfgfile)
raise UsageException.new("Not a regular file: #{cfgfile}") unless File::stat(cfgfile).file?

cfg = RAWSTools::CloudManager.new(cfgfile, script_dir)
cfg.setparam("ttl", ttl) if ttl
where = nil
template = nil

case command
when "lookup"
	where, name = ARGV.shift(2)
	raise UsageException.new("Missing required argument") unless name
	if where == "public"
		zone = cfg["PublicDNSId"]
	else
		zone = cfg["PrivateDNSId"]
	end
	values = cfg.route53.lookup(name, zone)
	if values.length() > 0
		values.each() { |value| puts value }
	else
		puts
	end
	exit 0
when "cname"
	where, cname, name = ARGV.shift(3)
	raise UsageException.new("Missing required argument") unless cname
	cfg.setparam("name", name)
	cfg.setparam("cname", cname)
	template = "cname"
	puts "Pointing #{cname} to #{name} using template cname"
when "arec"
	where, name, ipaddr = ARGV.shift(3)
	raise UsageException.new("Missing required argument") unless ipaddr
	cfg.setparam("name", name)
	cfg.setparam("ipaddr", ipaddr)
	template = "arec"
	puts "Pointing #{name} to #{ipaddr} using template arec"
when "txt"
	where, name, txtvalue = ARGV.shift(3)
	raise UsageException.new("Missing required argument") unless txtvalue
	cfg.setparam("name", name)

	# Break long TXT records up into 255 byte strings
	txtrecords = []
	while txtvalue.length > 255
		txtrecords << { :value => "\"#{txtvalue[0..254]}\"" }
		txtvalue = txtvalue[255..-1]
	end
	txtrecords << { :value => "\"#{txtvalue}\"" }

	cfg.setparam("txtrecords", txtrecords)
	template = "txt"
	puts "Pointing #{name} to #{txtrecords} using template txt"
end

change_ids = []
if where == "public" or where == "both"
	puts "Updating public zone"
	cfg.setparam("zone_id", cfg["PublicDNSId"])
	change_ids << cfg.route53.change_records(template)
end
if where == "private" or where == "both"
	puts "Updating private zone"
	cfg.setparam("zone_id", cfg["PrivateDNSId"])
	change_ids << cfg.route53.change_records(template)
end

if wait
	puts "... waiting for zone(s) to synchronize"
	change_ids.each() { |id| cfg.route53.wait_sync(id) }
	puts "synchronized"
end

rescue UsageException => e
	puts "\n#{e.message}\n\n"
	puts opts.help()
end
